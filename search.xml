<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue相关知识点]]></title>
    <url>%2F2018%2F02%2F01%2Fvue%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Vue的整体机制]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>思考</tag>
        <tag>知识点整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[失败经验总结]]></title>
    <url>%2F2018%2F01%2F31%2F%E5%A4%B1%E8%B4%A5%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[下次每次电话面试都记得录音 ···一直觉得阿里的前端是前端这边的标杆。希望能以阿里的前端为标准要求自己，自己进步并跟上步伐。最近一次阿里的面试是目前数次阿里面试中，面试次数最多的一次，也发现了更多自己的不足。 面试经历一面（电话面）聊了不少，半个小时左右。 1.vue-router实现原理2.vuex实现原理3.浏览器渲染机制4.各个浏览器内核以及兼容问题5.移动端适配 二面（现场面）二面的时候比较轻松 1.为什么用vue2.遇到难点3.自己满意的点4.weex 三面（电话面）—— 跪了三面的时候十分紧张,脑袋有点秀逗 vue相关 1.Vue双向绑定原理2.vue-router实现原理3.vue list中 子元素 绑定事件4.vue中列表 下一页之后返回上一页是否重新加载视图 weex相关1.weex实现基本原理2.weex的不足3.weex中的渲染机制 JS/css 1.点击事件 浏览器兼容问题2.移动事件 ontouchmove 以及优化 事件节流比如首先生成一个 独立 重绘的BFC渲染层。然后通过 CSS的相关动画来 控制dom的移动而不是通过JS直接修改 DOM 的位置。在往下就是 通过requestAnimationFrame来优化渲染 3.动画卡顿的问题 4.翻页动效 实现 其他1.最新信息/技术 获取以及了解2.自己的优势3.不用框架 你做过什么4.webpack loader 与 plugin 总结 [x] 1.深入了解下Vue的相关原理以及实现(vue, vue-router, vuex) [ ] 2.自己写一个简单MVVM框架 [ ]3.Webpack相关的知识点再复习一遍 [ ]4.自己着手写一下 loader 以及 plugin [ ]5.浏览器渲染机制 [ ]6.css3动画 [ ]7.weex相关的原理以及实现 再加最新信息 [ ]8.总结优势]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密算法(一) —— 对称加密]]></title>
    <url>%2F2017%2F09%2F18%2F%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[前言web前端这个概念其实是在近几年才突出出来！它的前身其实就是传说中的切图工(把UI出的图切出来放在对的地方就好)。前后端分离后, web前端要承当的是事情变的越来越多,代码量也越变越大。前端工程化,构建编译,加密… 近期在整理web前端用到的一些加密技术以及相关的工具。 对称加密算法 (DES、3DES、AES)1.简介1.1 定义对称加密算法是应用较早的加密算法，技术成熟。在对称加密算法中，数据发信方将明文（原始数据）和加密密钥（mi yue）一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。收信方收到密文后，若想解读原文，则需要使用加密用过的密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密密钥。 1.2 优缺点 优点：算法公开、计算量小、加密速度快、加密效率高。缺点：（1）交易双方都使用同样钥匙，安全性得不到保证。（2）每对用户每次使用对称加密算法时，都需要使用其他人不知道的惟一钥匙，这会使得发收信双方所拥有的钥匙数量呈几何级数增长，密钥管理成为用户的负担。对称加密算法在分布式网络系统上使用较为困难，主要是因为密钥管理困难，使用成本较高。 1.3 常用对称加密算法基于“对称密钥”的加密算法主要有DES、3DES（TripleDES）、AES、RC2、RC4、RC5和Blowfish等。比较常用的对称加密算法基本上就 DES、3DES（TripleDES）和AES。 DES（Data Encryption Standard）3DES（DES加强版，使用3次DES计算，Triple DES，DESede）AES（Advanced Encryption Standard，3DES加强版） 2.分组模式2.1 EBC模式 优点：1.简单；2.有利于并行计算；3.误差不会被传送； 缺点：1.不能隐藏明文的模式；2.可能对明文进行主动攻击。 2.2 EBC模式 —— 密码分组链接模式 优点：1.不容易主动攻击,安全性好于ECB,适合传输长度长的报文,是SSL、IPSec的标准。 缺点：1、不利于并行计算；2、误差传递；3、需要初始化向量IV。 2.3 CFB模式 —— 密码发反馈模式 优点：1、隐藏了明文模式；2、分组密码转化为流模式；3、可以及时加密传送小于分组的数据。 缺点:1、不利于并行计算；2、误差传送：一个明文单元损坏影响多个单元；3、唯一的IV。 2.4 OFB模式 —— 输出反馈模式 优点：1、隐藏了明文模式；2、分组密码转化为流模式；3、可以及时加密传送小于分组的数据。 缺点：1、不利于并行计算；2、对明文的主动攻击是可能的；3、误差传送：一个明文单元损坏影响多个单元。 2.5 CTR模式 计数模式（CTR模式）加密是对一系列输入数据块(称为计数)进行加密，产生一系列的输出块，输出块与明文异或得到密文。对于最后的数据块，可能是长u位的局部数据块，这u位就将用于异或操作，而剩下的b-u位将被丢弃（b表示块的长度）。CTR解密类似。这一系列的计数必须互不相同的。假定计数表示为T1, T2, …, Tn。CTR模式可定义如下： CTR加密公式如下：Cj = Pj XOR Ek(Tj)Cn = Pn XOR MSBu(Ek(Tn)) j = 1，2… n-1; CTR解密公式如下：Pj = Cj XOR Ek(Tj)Pn = Cn XOR MSBu(Ek(Tn)) j = 1，2 … n-1; AES CTR模式的结构如下图所示 加密方式：密码算法产生一个16 字节的伪随机码块流，伪随机码块与输入的明文进行异或运算后产生密文输出。密文与同样的伪随机码进行异或运算后可以重产生明文。 CTR 模式被广泛用于 ATM 网络安全和 IPSec应用中，相对于其它模式而言，CRT模式具有如下特点：硬件效率：允许同时处理多块明文 / 密文。软件效率：允许并行计算，可以很好地利用 CPU 流水等并行技术。预处理：算法和加密盒的输出不依靠明文和密文的输入，因此如果有足够的保证安全的存储器，加密算法将仅仅是一系列异或运算，这将极大地提高吞吐量。随机访问：第 i 块密文的解密不依赖于第 i-1 块密文，提供很高的随机访问能力可证明的安全性：能够证明 CTR 至少和其他模式一样安全（CBC, CFB, OFB, …）简单性：与其它模式不同，CTR模式仅要求实现加密算法，但不要求实现解密算法。对于 AES 等加/解密本质上不同的算法来说，这种简化是巨大的。无填充，可以高效地作为流式加密使用。 3.填充模式进行DES、3DES和AES三种对称加密算法时，常采用的是NoPadding（不填充）、Zeros填充（0填充）、PKCS7Padding填充。 3.1 ZeroPadding 全部填充为0的字节，结果如下：F1 F2 F3 F4 F5 F6 F7 F8 //第一块F9 00 00 00 00 00 00 00 //第二块 3.2 PKCS7Padding 每个填充的字节都记录了填充的总字节数，结果如下：F1 F2 F3 F4 F5 F6 F7 F8 //第一块F9 07 07 07 07 07 07 07 //第二块 web前端实例 —— crypto-js没看错 就是web前端！ 本实例使用的 crypto-js。安装 crypto-js 是的简单 123npm install crypto-js -S// 或者yarn add crypto-js 实例 —— Triple DES1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import CryptoJS from &apos;crypto-js&apos;var str = &apos;123456&apos;var key = &apos;0123456789abcdef&apos;var iv = &apos;0123456789abcdef&apos; key = CryptoJS.enc.Utf8.parse(key)iv = CryptoJS.enc.Utf8.parse(iv) // DES 加密var encrypted = CryptoJS.DES.encrypt(str, key, &#123; iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7&#125;) // 转换为字符串encrypted = encrypted.toString() // DES 解密var decrypted = CryptoJS.DES.decrypt(encrypted, key, &#123; iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7&#125;) // 转换为 utf8 字符串decrypted = CryptoJS.enc.Utf8.stringify(decrypted) // Triple DES 加密var encrypted = CryptoJS.TripleDES.encrypt(str, key, &#123; iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7&#125;) // 转换为字符串encrypted = encrypted.toString() // Triple DES 解密var decrypted = CryptoJS.TripleDES.decrypt(encrypted, key, &#123; iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7&#125;) // 转换为 utf8 字符串decrypted = CryptoJS.enc.Utf8.stringify(decrypted)]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>加密算法</tag>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为了以后的自己能偷懒]]></title>
    <url>%2F2017%2F09%2F06%2F%E4%B8%BA%E4%BA%86%E4%BB%A5%E5%90%8E%E7%9A%84%E8%87%AA%E5%B7%B1%E8%83%BD%E5%81%B7%E6%87%92%2F</url>
    <content type="text"><![CDATA[在项目开发的过程的经常会做一些重复的工作以及遇到一些类似的问题！ 特别在新开一个工程的时候！ API接口目前大部分的工程开发都已经做到了前后端分离。后端的小伙伴提供api接口,作为前端的我们使用ajax调用api接口获取数据，再渲染出相对应的界面！在实际的项目中，可能会遇到以下几个问题 前后端同步开发时, Mock的使用1234567891011121314151617181920212223242526272829303132const express = require(&apos;express&apos;)const router = express.Router()// 使用 Mockvar Mock = require(&apos;mockjs&apos;)router.get(&apos;/test&apos;, (req, res) =&gt; &#123; var data = Mock.mock(&#123; // 属性 list 的值是一个数组，其中含有 1 到 10 个元素 &apos;list|10&apos;: [&#123; // 属性 id 是一个自增数，起始值为 1，每次增 1 &apos;id|+1&apos;: 1, &apos;task_id|+1&apos;: 1, &apos;name|1&apos;: &apos;@cname()&apos;, &apos;time_begin&apos;: &apos;@datetime(&quot;yyyy-MM-dd HH:mm:ss&quot;)&apos;, &apos;time_end&apos;: &apos;@datetime(&quot;yyyy-MM-dd HH:mm:ss&quot;)&apos; &#125;] &#125;) res.json(&#123; code: 200, message: data &#125;)&#125;)router.get(&apos;*&apos;, (req, res) =&gt; &#123; res.json(&#123; code: -200, message: &apos;没有找到该页面&apos; &#125;)&#125;)module.exports = router 初始化模板 —— 后台管理篇1vue init 1xuanyuan1/admin-cli my-project]]></content>
      <categories>
        <category>全栈</category>
      </categories>
      <tags>
        <tag>组件</tag>
        <tag>偷懒</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SPA预渲染]]></title>
    <url>%2F2017%2F09%2F05%2FSPA%E9%A2%84%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[如果你要预呈现页面来更好地支持 SEO，使用 Webpack 插件：prerender-spa-plugin ，经过测试这是可以在 vue 中使用的。对于经常变动的页面，Prerender.io 和 Netlify 提供预呈现功能从而更好地支持搜索引擎。 SPA预渲染 —— 使用 prerender-spa-plugin1.安装插件1npm install --save-dev prerender-spa-plugin 或者1yarn add prerender-spa-plugin -D 2.在 build/webpack.prod.conf.js 文件中里使用1234567891011121314// 放在文件顶部var PrerenderSpaPlugin = require(&apos;prerender-spa-plugin&apos;)...plugins: [ new PrerenderSpaPlugin( // 要编译的目录 path.join(__dirname, &apos;../dist&apos;), // 你要预呈现的列表 [ &apos;/&apos; ] ) ...] 如果你想预呈现 /about 和 /contact，那么列表就是 [ ‘/‘, ‘/about’, ‘/contact’ ]]]></content>
      <categories>
        <category>全栈</category>
      </categories>
      <tags>
        <tag>预渲染</tag>
        <tag>prerender-spa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试问题小结]]></title>
    <url>%2F2017%2F08%2F30%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1.跨域介绍 为了保证使用者信息的安全，防止恶意网站篡改用户数据 只要协议、域名、端口有任何一个不同，都被当作是不同的域，之间的请求就是跨域操作 解决1).CORS（跨域资源访问）后端设置 Access-Control-Allow-Origin: origin | ‘‘ 允许某个指定的域访问，表示不限制域。 Access-Control-Allow-Methods: ‘GET,POST,PUT,DELETE’ 允许哪些类型的请求 Access-Control-Allow-Headers: ‘x-token’ 允许的自定义Header。 2).代理通过同源的api调用跨域的api, 服务端没有跨域的问题 3).jsonp2.CSRF和XSS XSS：跨站脚本（Cross-site scripting，通常简称为XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。 CSRF:跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。 很多同学会搞不明白XSS与CSRF的区别，虽然这两个关键词时常抱团出现，但他们两个是不同维度的东西（或者说他们的目的是不一样的）。XSS更偏向于方法论，CSRF更偏向于一种形式，只要是伪造用户发起的请求，都可成为CSRF攻击。 3.浏览器的渲染过程 DOM -&gt; CSSOM -&gt; render -&gt; layout -&gt; print 4.虚拟DOM、Diff算法、vuex和redux、weex和reactNative1).虚拟DOM把DOM存入内存, 不直接操作真实的DOM 先修改虚拟DOM 再把更改后的变化同步到真实DOM ps.虚拟DOM的推出 使weex &amp; reactNative等用JS写UI ios、Android或者web 负责渲染的方式让一套代码三端通用成功可能！ 2).Diff算法 在标准diff机制下：在同一位置对比前后的dom节点，发现节点改变了，会继续比较该节点的子节点，一层层对比，找到不同的节点，然后更新节点。 在react的diff算法下，在同一位置对比前后dom节点,只要发现不同，就会删除操作前的domm节点（包括其子节点），替换为操作后的dom节点。 在vue的diff算法下，有无设置key尽量不要跨层级的修改dom设置key可以最大化的利用节点不要盲目相信diff的效率，在必要时可以手工优化 5.常用的ES6 1.函数参数默认值2.模板字符串3.解构赋值4.对象属性简写5.箭头函数6.Promise7.Let与Const8.类9.模块化 6.SSR(服务端渲染) weexjs代码打包成bundle 然后用 各个端的渲染器来渲染相应的页面 7.遇到的问题，以及解决8.typescipt9.cancel request10.与后端配合前端比较倾向于展示所需要的数据, 后端比较倾向于输出模型相关的数据 两者其实是有冲突的常规的是前端拿到模型相关的数据 如果做数据清洗 转换为展示所需的数据 可以将数据清洗的部分抽取出来 做一个node的中间层]]></content>
      <categories>
        <category>小知识</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>小知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通往财富自由之路(一)]]></title>
    <url>%2F2017%2F08%2F29%2F%E9%80%9A%E5%BE%80%E8%B4%A2%E5%AF%8C%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[注意力 三个大坑1.莫名其妙的凑热闹路边围观,网上围观 即传说中的吃瓜群众！ 2.心急火燎的随大流~~~~跟随趋势！ 一旦什么东西火了就心急火燎的去随大流！ —— 趋势不属于心急火燎的人 机会是属于有准备的人 ——&gt; 做好自己的积累 3.操碎了别人的心别人的事 成功与否与我何干！！！ 结论注意力在一天内其实很少！ 注意力是你最宝贵的财富！！！ 把注意力放在自己的成长上！ 生活/创业 都是成长 每天一点点的的成长就是最好的财富 付费 凡是能用钱买的就是便宜的~~~！！！ 注意力 &gt; 时间 &gt; 金钱 时间 vs 金钱比如说外卖~ 在撸代码的时候 花几块钱让别人送个外卖过来 在同等时间内我敲代码产生的效益比这个更有价值 特别是起身去买外卖的时候会打扰目前撸代码的时的注意力 注意力 vs 时间注意力能创建价值 而时间并不一定 特别是有些时候我们还想要去杀死时间！ 撸游戏、看热闹！~~ 安全感]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[https配置]]></title>
    <url>%2F2017%2F07%2F31%2Fhttps%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[https配置1234567891011121314151617181920212223server &#123; listen 80; server_name hr.dduke.me; rewrite ^(.*) https://$host$1 permanent;&#125;server &#123; listen 443; server_name hr.dduke.me; #rewrite ^(.*) https://$host$1 permanent; ssl on; ssl_certificate 1_hr.dduke.me_bundle.crt; ssl_certificate_key 2_hr.dduke.me.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置 ssl_prefer_server_ciphers on; location / &#123; proxy_pass http://127.0.0.1:8082; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125;]]></content>
      <categories>
        <category>全栈</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mongoose Date小坑]]></title>
    <url>%2F2017%2F07%2F18%2FMongoose%20Date%E5%B0%8F%E5%9D%91%2F</url>
    <content type="text"><![CDATA[Mongoose Date小坑今天在用nodejs做后端 mongo做数据库的一个应用时发的一个坑。 12345678910111213// 假设有这样一个状态let where = &#123; create_date: &#123; $gte: "2017-07-10T16:00:00.000Z", $lt: "2017-07-17T16:00:00.000Z" &#125;&#125;mongoDB.find(where).exec().then(result =&gt; &#123; console.log(result) // 该处能正常查询获取到数据&#125;)mongoDB.aggregate().match(where).exec().then(result =&gt; &#123; console.log(result) // 该处不能正常查询获取到数据&#125;) find时 Date类型的数据可以直接用字符串 match时不行! 思考解决若将其转化为 Date类型是否可行 ？ 故做了以下测试 123456789101112let where = &#123; create_date: &#123; $gte: new Date("2017-07-10T16:00:00.000Z"), $lt: new Date("2017-07-17T16:00:00.000Z") &#125;&#125;mongoDB.find(where).exec().then(result =&gt; &#123; console.log(result) // 该处能正常查询获取到数据&#125;)mongoDB.aggregate().match(where).exec().then(result =&gt; &#123; console.log(result) // 该处能正常查询获取到数据&#125;) OK fixed! ps.这个算 mongoose的bug吗？ 哈哈😄]]></content>
      <categories>
        <category>踩坑</category>
      </categories>
      <tags>
        <tag>Mongoose</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个服务器多端口多域名]]></title>
    <url>%2F2017%2F07%2F04%2F%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%9A%E7%AB%AF%E5%8F%A3%E5%A4%9A%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[前言本人比较穷,就只买了一台服务器玩玩。域名的话可以有很多(子域名基本上可以无限建)，为了给每个项目都分配一个域名，并且都能通过80端口访问到。(ps.域名后面再加一个端口 看起来有点蛋疼) 正题使用的是nginx做端口转发，实现起来也比较简单。修改nginx的配置(本文系统是基于Centos 7),若使用yum install的话 nginx的配置文件路径为 /etc/nginx/nginx.conf, 具体代码参考如下: 1234567891011121314151617181920server &#123; listen 80; server_name chat.dduke.me; location / &#123; proxy_pass http://127.0.0.1:8080; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125;server &#123; listen 80; server_name topasm.dduke.me; location / &#123; proxy_pass http://127.0.0.1:8081; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; ps.配置完后 不要忘记重新加载nginx配置1nginx -s reload]]></content>
      <categories>
        <category>全栈</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>域名绑定</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 for javascript]]></title>
    <url>%2F2017%2F06%2F26%2F%E7%AE%97%E6%B3%95%20for%20javascript%2F</url>
    <content type="text"><![CDATA[为什么要学习算法(for javascript)学java出身,对算法这个东西有个一定的了解，然而对应带javascript上来，其实是一脸懵逼的。对目前从事前端的本人来说，把这个搞定，自认是至关重要的。之前写的博客，数据被黑，里面的数据全被清空了 ，这个新的博客算一个新的开始吧。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>算法</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F04%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Hello world</tag>
      </tags>
  </entry>
</search>
