<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS-new]]></title>
    <url>%2F2018%2F04%2F03%2FJS-new%2F</url>
    <content type="text"><![CDATA[JS中并没有类的概念,但是经常性会看到 var test = new Test(&#39;duke&#39;) 这样的写法。很像java里构造实例的方式。 123456789101112131415161718// ES5function Test(name) &#123; this.name = name&#125;// 等价于function Test(name) &#123; var obj = Object.create(Test.prototype) obj.name = name return obj&#125;// ES6class Test &#123; constructor (name) &#123; this.name = name &#125;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weex快速开发三端应用：做一个看书软件]]></title>
    <url>%2F2018%2F03%2F20%2FWeex%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E4%B8%89%E7%AB%AF%E5%BA%94%E7%94%A8%EF%BC%9A%E5%81%9A%E4%B8%80%E4%B8%AA%E7%9C%8B%E4%B9%A6%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[小册内容 [ ] 1.weex 基本原理 [ ] 2.weex 脚手架的使用 [ ] 3.weex 的一些基本组件 [ ] 4.搭建第一个 weex 页面 [ ] 5.推荐书籍页 &amp; 网络请求 [ ] 6.我的书架 &amp; 本地缓存 [ ] 7.书籍目录 &amp; 长列表处理 [ ] 8.页面之间传值 [ ] 9.真机运行与调试 [ ] 10.云打包工具 —— 轻舟 [ ] 11.小结 什么是 Weex ？ Weex 是一个使用 Web 开发体验来开发高性能原生应用的框架。 Weex 致力于使开发者能基于当代先进的 Web 开发技术，使用同一套代码来构建 Android、iOS 和 Web 应用。具体来讲，在集成了 WeexSDK 之后，你可以使用 JavaScript 和现代流行的前端框架来开发移动应用。 Weex 的结构是解耦的，渲染引擎与语法层是分开的，也不依赖任何特定的前端框架，目前主要支持 Vue.js 和 Rax 这两个前端框架。 VueVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。目前主流的三大框架之一，本小册就是用的 Vue 框架开做 Weex 的语法层。详情可参阅这里。 RaxRax 是一个兼容 React 接口的前端框架。详情可参阅这里。 为什么要学 Weex？写过H5的同学肯定会被它的简单高效、发布即更新、一条URL可适配多端等这些快所吸引，但写过 Native 的同学肯定也会被 Native 的富交互、性能体验、可调用原生能力、可管理内存等特性给我们的业务带来更好的体验。 快与体验兼得 你会学到什么？ weex 基本原理 weex 脚手架的使用 weex 基本组件的使用 weex 的网页调试&amp;真机调试 实战中遇到的一些坑以及相应的解决方案 你需要准备什么？需要你懂一些HTML, CSS 与 JS 的基础，因为本课程是使用 Vue 来做 weex 的语法层，如果你有一定的 Vue 基础，你将更好的学习。 一台移动设备（Android或者iOS手机） 一台可以联网的电脑 还需要一点点的前端基础 购买须知 本小册为图文形式内容服务，共计 11 节； 购买用户可享有小册永久的阅读权限； 购买用户可进入小册微信群，与作者互动； 掘金小册为虚拟内容服务，一经购买成功概不退款； 掘金小册版权归北京北比信息技术有限公司所有，任何机构、媒体、网站或个人未经本网协议授权不得转载、链接、转贴或以其他方式复制发布/发表，违者将依法追究责任； 在掘金小册阅读过程中，如有任何问题，请邮件联系 xiaoce@xitu.io]]></content>
      <categories>
        <category>小册子</category>
      </categories>
      <tags>
        <tag>小册子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue相关知识点]]></title>
    <url>%2F2018%2F02%2F01%2Fvue%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Vue的整体机制 主要流程为 初始化及挂载 =&gt; 编译 =&gt; 响应式 =&gt; Virtual DOM =&gt; 更新视图 初始化及挂载new Vue()的时候,Vue会调用一个 _init 函数，它会初始化Vue的生命周期、事件、data等，其中最重要的是通过 Object.defineProperty 设置 setter 与 getter 函数，来实现[响应式]以及[依赖收集]。 初始化之后会调用 $mount 函数挂载组件，如果是运行时编译，即不存在 render function 但是存在 template 的情况，需要进行[编译]步骤。 编译]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>思考</tag>
        <tag>知识点整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本知识]]></title>
    <url>%2F2018%2F01%2F31%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[基本定义一级函数在 JavaScript 中，函数是一级函数。这意味着，就像对象一样，你可以像处理其他元素（如数字、字符串、数组等）一样来处理函数。JavaScript 函数可以： 1.存储在变量中。2.从一个函数返回。3.作为参数传递给另一个函数。 高阶函数返回另一个函数的函数 与 具有函数参数的函数 被称为高阶函数。 12345678910111213function test () &#123; return function () &#123; &#125;&#125;function test1 () &#123;&#125;function test2 (callback) &#123; callback()&#125;test2(test1) 回调函数作为参数传递给另一个函数的函数被称为回调函数。 闭包 函数保留对其作用域的访问的这个过程被称为闭包 闭包的作用 隐含地传递参数。在函数声明中，存储作用域的快照。 123456789function remember(number) &#123; return function() &#123; return number; &#125;&#125;const returnedFunction = remember(5);console.log( returnedFunction() ); // 打印数字 5 立即调用函数表达式立即调用函数表达式或 IIFE（发音为 iffy）是在定义之后立即被调用的函数。 新单词instanceof constructor]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[失败经验总结]]></title>
    <url>%2F2018%2F01%2F31%2F%E5%A4%B1%E8%B4%A5%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[下次每次电话面试都记得录音 ···一直觉得阿里的前端是前端这边的标杆。希望能以阿里的前端为标准要求自己，自己进步并跟上步伐。最近一次阿里的面试是目前数次阿里面试中，面试次数最多的一次，也发现了更多自己的不足。 面试经历一面（电话面）聊了不少，半个小时左右。 1.vue-router实现原理2.vuex实现原理3.浏览器渲染机制4.各个浏览器内核以及兼容问题5.移动端适配 二面（现场面）二面的时候比较轻松 1.为什么用vue2.遇到难点3.自己满意的点4.weex 三面（电话面）—— 跪了三面的时候十分紧张,脑袋有点秀逗 vue相关 1.Vue双向绑定原理2.vue-router实现原理3.vue list中 子元素 绑定事件4.vue中列表 下一页之后返回上一页是否重新加载视图 weex相关1.weex实现基本原理2.weex的不足3.weex中的渲染机制 JS/css 1.点击事件 浏览器兼容问题2.移动事件 ontouchmove 以及优化 事件节流比如首先生成一个 独立 重绘的BFC渲染层。然后通过 CSS的相关动画来 控制dom的移动而不是通过JS直接修改 DOM 的位置。在往下就是 通过requestAnimationFrame来优化渲染 放入队列中 固定时间执行一次 3.动画卡顿的问题这个问题应该问的的浏览器渲染以及重绘方面的问题，主要包括以下五个步骤正常情况下可分为三种情况,Javascript 与 Style 必不可少的 1.Layout Paint Composite; margin, padding, height等改变布局的 2.Paint Composite; color等不改变布局只改变样式的 3.Composite; opacity,transform等只改变图层的 具体可以参照这里 ps. 可以引入 60帧/s 即一帧在16ms内完成才能回不造成卡顿，实际情况下浏览器处理仍然需要实际，故要将每帧动画控制在10ms左右 再ps. setTimeout, setInterval 与 requestAnimationFrame使用 requestAnimationFrame 能将 javascript 放在每帧的最开始的时候，避免了中途重绘、丢帧的情况(requestAnimationFrame 在 IE9 浏览器中不支持 可以使用 polyfill会使用setTimeout替代) 4.翻页动效 实现 其他1.最新信息/技术 获取以及了解微信公众号,知乎, 掘金，segmentfault,V2EV, 2.自己的优势以及发展工作五年一直做的事情都是偏业务的，不是一个技术极客，就目前而言的所学的技术都是跟随者业务来走的，jsp + servlet =&gt; 前后端分离 =&gt; 工程化开发，Vue SSR 因为有SEO方面的需求，小公司的的需求敏捷开发，快速迭代 =&gt; 制作了一个能快速开始项目的脚手架，一个简单的组件库，weex一套代码 三端通用。业务方面不仅仅在技术上实现就好，需要跟运营，市场，产品沟通也是非常重要的。在这方面我比较多的经验。开发前明确捕捉到真正的需求，能大大的增加开发效率以及减少后续的返工·比如说后台管理系统以及一些内部的系统，在美观以及动效等方面其实没有太多的需求，对于数据，图表有着比较大的要求，而在to C 的web应用上对用户体验，动效等方面要求就比较好·未来可能会往管理岗位发展，就本人的工作经历而已其实涵盖了技术开发的很多方面，有便于多方协调，本人的性格方面也挺适合。不足的是，目前主要的手段是和事老以及兜底，目前重心还是会放在技术上，争取在前端方向发展出了什么样的问题 都能完美的兜底。 3.不用框架 你做过什么 4.webpack loader 与 pluginloader 用于加载某些资源文件。plugin 用于扩展webpack的功能。 总结 [x]1.深入了解下Vue的相关原理以及实现(vue, vue-router, vuex) [ ]2.自己写一个简单MVVM框架 [ ]3.Webpack相关的知识点再复习一遍 [ ]4.自己着手写一下 loader 以及 plugin [ ]5.浏览器渲染机制 [ ]6.css3动画 [ ]7.weex相关的原理以及实现 再加最新信息 [ ]8.总结优势]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密算法(一) —— 对称加密]]></title>
    <url>%2F2017%2F09%2F18%2F%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[前言web前端这个概念其实是在近几年才突出出来！它的前身其实就是传说中的切图工(把UI出的图切出来放在对的地方就好)。前后端分离后, web前端要承当的是事情变的越来越多,代码量也越变越大。前端工程化,构建编译,加密… 近期在整理web前端用到的一些加密技术以及相关的工具。 对称加密算法 (DES、3DES、AES)1.简介1.1 定义对称加密算法是应用较早的加密算法，技术成熟。在对称加密算法中，数据发信方将明文（原始数据）和加密密钥（mi yue）一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。收信方收到密文后，若想解读原文，则需要使用加密用过的密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密密钥。 1.2 优缺点 优点：算法公开、计算量小、加密速度快、加密效率高。缺点：（1）交易双方都使用同样钥匙，安全性得不到保证。（2）每对用户每次使用对称加密算法时，都需要使用其他人不知道的惟一钥匙，这会使得发收信双方所拥有的钥匙数量呈几何级数增长，密钥管理成为用户的负担。对称加密算法在分布式网络系统上使用较为困难，主要是因为密钥管理困难，使用成本较高。 1.3 常用对称加密算法基于“对称密钥”的加密算法主要有DES、3DES（TripleDES）、AES、RC2、RC4、RC5和Blowfish等。比较常用的对称加密算法基本上就 DES、3DES（TripleDES）和AES。 DES（Data Encryption Standard）3DES（DES加强版，使用3次DES计算，Triple DES，DESede）AES（Advanced Encryption Standard，3DES加强版） 2.分组模式2.1 EBC模式 优点：1.简单；2.有利于并行计算；3.误差不会被传送； 缺点：1.不能隐藏明文的模式；2.可能对明文进行主动攻击。 2.2 EBC模式 —— 密码分组链接模式 优点：1.不容易主动攻击,安全性好于ECB,适合传输长度长的报文,是SSL、IPSec的标准。 缺点：1、不利于并行计算；2、误差传递；3、需要初始化向量IV。 2.3 CFB模式 —— 密码发反馈模式 优点：1、隐藏了明文模式；2、分组密码转化为流模式；3、可以及时加密传送小于分组的数据。 缺点:1、不利于并行计算；2、误差传送：一个明文单元损坏影响多个单元；3、唯一的IV。 2.4 OFB模式 —— 输出反馈模式 优点：1、隐藏了明文模式；2、分组密码转化为流模式；3、可以及时加密传送小于分组的数据。 缺点：1、不利于并行计算；2、对明文的主动攻击是可能的；3、误差传送：一个明文单元损坏影响多个单元。 2.5 CTR模式 计数模式（CTR模式）加密是对一系列输入数据块(称为计数)进行加密，产生一系列的输出块，输出块与明文异或得到密文。对于最后的数据块，可能是长u位的局部数据块，这u位就将用于异或操作，而剩下的b-u位将被丢弃（b表示块的长度）。CTR解密类似。这一系列的计数必须互不相同的。假定计数表示为T1, T2, …, Tn。CTR模式可定义如下： CTR加密公式如下：Cj = Pj XOR Ek(Tj)Cn = Pn XOR MSBu(Ek(Tn)) j = 1，2… n-1; CTR解密公式如下：Pj = Cj XOR Ek(Tj)Pn = Cn XOR MSBu(Ek(Tn)) j = 1，2 … n-1; AES CTR模式的结构如下图所示 加密方式：密码算法产生一个16 字节的伪随机码块流，伪随机码块与输入的明文进行异或运算后产生密文输出。密文与同样的伪随机码进行异或运算后可以重产生明文。 CTR 模式被广泛用于 ATM 网络安全和 IPSec应用中，相对于其它模式而言，CRT模式具有如下特点：硬件效率：允许同时处理多块明文 / 密文。软件效率：允许并行计算，可以很好地利用 CPU 流水等并行技术。预处理：算法和加密盒的输出不依靠明文和密文的输入，因此如果有足够的保证安全的存储器，加密算法将仅仅是一系列异或运算，这将极大地提高吞吐量。随机访问：第 i 块密文的解密不依赖于第 i-1 块密文，提供很高的随机访问能力可证明的安全性：能够证明 CTR 至少和其他模式一样安全（CBC, CFB, OFB, …）简单性：与其它模式不同，CTR模式仅要求实现加密算法，但不要求实现解密算法。对于 AES 等加/解密本质上不同的算法来说，这种简化是巨大的。无填充，可以高效地作为流式加密使用。 3.填充模式进行DES、3DES和AES三种对称加密算法时，常采用的是NoPadding（不填充）、Zeros填充（0填充）、PKCS7Padding填充。 3.1 ZeroPadding 全部填充为0的字节，结果如下：F1 F2 F3 F4 F5 F6 F7 F8 //第一块F9 00 00 00 00 00 00 00 //第二块 3.2 PKCS7Padding 每个填充的字节都记录了填充的总字节数，结果如下：F1 F2 F3 F4 F5 F6 F7 F8 //第一块F9 07 07 07 07 07 07 07 //第二块 web前端实例 —— crypto-js没看错 就是web前端！ 本实例使用的 crypto-js。安装 crypto-js 是的简单 123npm install crypto-js -S// 或者yarn add crypto-js 实例 —— Triple DES1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import CryptoJS from &apos;crypto-js&apos;var str = &apos;123456&apos;var key = &apos;0123456789abcdef&apos;var iv = &apos;0123456789abcdef&apos; key = CryptoJS.enc.Utf8.parse(key)iv = CryptoJS.enc.Utf8.parse(iv) // DES 加密var encrypted = CryptoJS.DES.encrypt(str, key, &#123; iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7&#125;) // 转换为字符串encrypted = encrypted.toString() // DES 解密var decrypted = CryptoJS.DES.decrypt(encrypted, key, &#123; iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7&#125;) // 转换为 utf8 字符串decrypted = CryptoJS.enc.Utf8.stringify(decrypted) // Triple DES 加密var encrypted = CryptoJS.TripleDES.encrypt(str, key, &#123; iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7&#125;) // 转换为字符串encrypted = encrypted.toString() // Triple DES 解密var decrypted = CryptoJS.TripleDES.decrypt(encrypted, key, &#123; iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7&#125;) // 转换为 utf8 字符串decrypted = CryptoJS.enc.Utf8.stringify(decrypted)]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>加密算法</tag>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为了以后的自己能偷懒]]></title>
    <url>%2F2017%2F09%2F06%2F%E4%B8%BA%E4%BA%86%E4%BB%A5%E5%90%8E%E7%9A%84%E8%87%AA%E5%B7%B1%E8%83%BD%E5%81%B7%E6%87%92%2F</url>
    <content type="text"><![CDATA[在项目开发的过程的经常会做一些重复的工作以及遇到一些类似的问题！ 特别在新开一个工程的时候！ API接口目前大部分的工程开发都已经做到了前后端分离。后端的小伙伴提供api接口,作为前端的我们使用ajax调用api接口获取数据，再渲染出相对应的界面！在实际的项目中，可能会遇到以下几个问题 前后端同步开发时, Mock的使用1234567891011121314151617181920212223242526272829303132const express = require(&apos;express&apos;)const router = express.Router()// 使用 Mockvar Mock = require(&apos;mockjs&apos;)router.get(&apos;/test&apos;, (req, res) =&gt; &#123; var data = Mock.mock(&#123; // 属性 list 的值是一个数组，其中含有 1 到 10 个元素 &apos;list|10&apos;: [&#123; // 属性 id 是一个自增数，起始值为 1，每次增 1 &apos;id|+1&apos;: 1, &apos;task_id|+1&apos;: 1, &apos;name|1&apos;: &apos;@cname()&apos;, &apos;time_begin&apos;: &apos;@datetime(&quot;yyyy-MM-dd HH:mm:ss&quot;)&apos;, &apos;time_end&apos;: &apos;@datetime(&quot;yyyy-MM-dd HH:mm:ss&quot;)&apos; &#125;] &#125;) res.json(&#123; code: 200, message: data &#125;)&#125;)router.get(&apos;*&apos;, (req, res) =&gt; &#123; res.json(&#123; code: -200, message: &apos;没有找到该页面&apos; &#125;)&#125;)module.exports = router 初始化模板 —— 后台管理篇1vue init 1xuanyuan1/admin-cli my-project]]></content>
      <categories>
        <category>全栈</category>
      </categories>
      <tags>
        <tag>组件</tag>
        <tag>偷懒</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SPA预渲染]]></title>
    <url>%2F2017%2F09%2F05%2FSPA%E9%A2%84%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[如果你要预呈现页面来更好地支持 SEO，使用 Webpack 插件：prerender-spa-plugin ，经过测试这是可以在 vue 中使用的。对于经常变动的页面，Prerender.io 和 Netlify 提供预呈现功能从而更好地支持搜索引擎。 SPA预渲染 —— 使用 prerender-spa-plugin1.安装插件1npm install --save-dev prerender-spa-plugin 或者1yarn add prerender-spa-plugin -D 2.在 build/webpack.prod.conf.js 文件中里使用1234567891011121314// 放在文件顶部var PrerenderSpaPlugin = require(&apos;prerender-spa-plugin&apos;)...plugins: [ new PrerenderSpaPlugin( // 要编译的目录 path.join(__dirname, &apos;../dist&apos;), // 你要预呈现的列表 [ &apos;/&apos; ] ) ...] 如果你想预呈现 /about 和 /contact，那么列表就是 [ ‘/‘, ‘/about’, ‘/contact’ ]]]></content>
      <categories>
        <category>全栈</category>
      </categories>
      <tags>
        <tag>预渲染</tag>
        <tag>prerender-spa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试问题小结]]></title>
    <url>%2F2017%2F08%2F30%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1.跨域介绍 为了保证使用者信息的安全，防止恶意网站篡改用户数据 只要协议、域名、端口有任何一个不同，都被当作是不同的域，之间的请求就是跨域操作 解决1).CORS（跨域资源访问）后端设置 Access-Control-Allow-Origin: origin | ‘‘ 允许某个指定的域访问，表示不限制域。 Access-Control-Allow-Methods: ‘GET,POST,PUT,DELETE’ 允许哪些类型的请求 Access-Control-Allow-Headers: ‘x-token’ 允许的自定义Header。 2).代理通过同源的api调用跨域的api, 服务端没有跨域的问题 3).jsonp2.CSRF和XSS XSS：跨站脚本（Cross-site scripting，通常简称为XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。 CSRF:跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。 很多同学会搞不明白XSS与CSRF的区别，虽然这两个关键词时常抱团出现，但他们两个是不同维度的东西（或者说他们的目的是不一样的）。XSS更偏向于方法论，CSRF更偏向于一种形式，只要是伪造用户发起的请求，都可成为CSRF攻击。 3.浏览器的渲染过程 DOM -&gt; CSSOM -&gt; render -&gt; layout -&gt; print 4.虚拟DOM、Diff算法、vuex和redux、weex和reactNative1).虚拟DOM把DOM存入内存, 不直接操作真实的DOM 先修改虚拟DOM 再把更改后的变化同步到真实DOM ps.虚拟DOM的推出 使weex &amp; reactNative等用JS写UI ios、Android或者web 负责渲染的方式让一套代码三端通用成功可能！ 2).Diff算法 在标准diff机制下：在同一位置对比前后的dom节点，发现节点改变了，会继续比较该节点的子节点，一层层对比，找到不同的节点，然后更新节点。 在react的diff算法下，在同一位置对比前后dom节点,只要发现不同，就会删除操作前的domm节点（包括其子节点），替换为操作后的dom节点。 在vue的diff算法下，有无设置key尽量不要跨层级的修改dom设置key可以最大化的利用节点不要盲目相信diff的效率，在必要时可以手工优化 5.常用的ES6 1.函数参数默认值2.模板字符串3.解构赋值4.对象属性简写5.箭头函数6.Promise7.Let与Const8.类9.模块化 6.SSR(服务端渲染) weexjs代码打包成bundle 然后用 各个端的渲染器来渲染相应的页面 7.遇到的问题，以及解决8.typescipt9.cancel request10.与后端配合前端比较倾向于展示所需要的数据, 后端比较倾向于输出模型相关的数据 两者其实是有冲突的常规的是前端拿到模型相关的数据 如果做数据清洗 转换为展示所需的数据 可以将数据清洗的部分抽取出来 做一个node的中间层]]></content>
      <categories>
        <category>小知识</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>小知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通往财富自由之路(一)]]></title>
    <url>%2F2017%2F08%2F29%2F%E9%80%9A%E5%BE%80%E8%B4%A2%E5%AF%8C%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[注意力 三个大坑1.莫名其妙的凑热闹路边围观,网上围观 即传说中的吃瓜群众！ 2.心急火燎的随大流~~~~跟随趋势！ 一旦什么东西火了就心急火燎的去随大流！ —— 趋势不属于心急火燎的人 机会是属于有准备的人 ——&gt; 做好自己的积累 3.操碎了别人的心别人的事 成功与否与我何干！！！ 结论注意力在一天内其实很少！ 注意力是你最宝贵的财富！！！ 把注意力放在自己的成长上！ 生活/创业 都是成长 每天一点点的的成长就是最好的财富 付费 凡是能用钱买的就是便宜的~~~！！！ 注意力 &gt; 时间 &gt; 金钱 时间 vs 金钱比如说外卖~ 在撸代码的时候 花几块钱让别人送个外卖过来 在同等时间内我敲代码产生的效益比这个更有价值 特别是起身去买外卖的时候会打扰目前撸代码的时的注意力 注意力 vs 时间注意力能创建价值 而时间并不一定 特别是有些时候我们还想要去杀死时间！ 撸游戏、看热闹！~~ 安全感]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[https配置]]></title>
    <url>%2F2017%2F07%2F31%2Fhttps%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[https配置1234567891011121314151617181920212223server &#123; listen 80; server_name hr.dduke.me; rewrite ^(.*) https://$host$1 permanent;&#125;server &#123; listen 443; server_name hr.dduke.me; #rewrite ^(.*) https://$host$1 permanent; ssl on; ssl_certificate 1_hr.dduke.me_bundle.crt; ssl_certificate_key 2_hr.dduke.me.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置 ssl_prefer_server_ciphers on; location / &#123; proxy_pass http://127.0.0.1:8082; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125;]]></content>
      <categories>
        <category>全栈</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mongoose Date小坑]]></title>
    <url>%2F2017%2F07%2F18%2FMongoose%20Date%E5%B0%8F%E5%9D%91%2F</url>
    <content type="text"><![CDATA[Mongoose Date小坑今天在用nodejs做后端 mongo做数据库的一个应用时发的一个坑。 12345678910111213// 假设有这样一个状态let where = &#123; create_date: &#123; $gte: "2017-07-10T16:00:00.000Z", $lt: "2017-07-17T16:00:00.000Z" &#125;&#125;mongoDB.find(where).exec().then(result =&gt; &#123; console.log(result) // 该处能正常查询获取到数据&#125;)mongoDB.aggregate().match(where).exec().then(result =&gt; &#123; console.log(result) // 该处不能正常查询获取到数据&#125;) find时 Date类型的数据可以直接用字符串 match时不行! 思考解决若将其转化为 Date类型是否可行 ？ 故做了以下测试 123456789101112let where = &#123; create_date: &#123; $gte: new Date("2017-07-10T16:00:00.000Z"), $lt: new Date("2017-07-17T16:00:00.000Z") &#125;&#125;mongoDB.find(where).exec().then(result =&gt; &#123; console.log(result) // 该处能正常查询获取到数据&#125;)mongoDB.aggregate().match(where).exec().then(result =&gt; &#123; console.log(result) // 该处能正常查询获取到数据&#125;) OK fixed! ps.这个算 mongoose的bug吗？ 哈哈😄]]></content>
      <categories>
        <category>踩坑</category>
      </categories>
      <tags>
        <tag>Mongoose</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个服务器多端口多域名]]></title>
    <url>%2F2017%2F07%2F04%2F%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%9A%E7%AB%AF%E5%8F%A3%E5%A4%9A%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[前言本人比较穷,就只买了一台服务器玩玩。域名的话可以有很多(子域名基本上可以无限建)，为了给每个项目都分配一个域名，并且都能通过80端口访问到。(ps.域名后面再加一个端口 看起来有点蛋疼) 正题使用的是nginx做端口转发，实现起来也比较简单。修改nginx的配置(本文系统是基于Centos 7),若使用yum install的话 nginx的配置文件路径为 /etc/nginx/nginx.conf, 具体代码参考如下: 1234567891011121314151617181920server &#123; listen 80; server_name chat.dduke.me; location / &#123; proxy_pass http://127.0.0.1:8080; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125;server &#123; listen 80; server_name topasm.dduke.me; location / &#123; proxy_pass http://127.0.0.1:8081; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; ps.配置完后 不要忘记重新加载nginx配置1nginx -s reload]]></content>
      <categories>
        <category>全栈</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>域名绑定</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 for javascript]]></title>
    <url>%2F2017%2F06%2F26%2F%E7%AE%97%E6%B3%95%20for%20javascript%2F</url>
    <content type="text"><![CDATA[为什么要学习算法(for javascript)学java出身,对算法这个东西有个一定的了解，然而对应带javascript上来，其实是一脸懵逼的。对目前从事前端的本人来说，把这个搞定，自认是至关重要的。之前写的博客，数据被黑，里面的数据全被清空了 ，这个新的博客算一个新的开始吧。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>算法</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F04%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Hello world</tag>
      </tags>
  </entry>
</search>
