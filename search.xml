<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[小程序的填坑小技巧(一)]]></title>
    <url>%2F2018%2F05%2F02%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%A1%AB%E5%9D%91%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[前言小程序在内测的时候就已经开始玩了，不过最开始的时候觉得，这sx东西东西怎么这么坑的样子，网络请求居然不是返回Promise而是用Callback的方式, 传值居然不能把值写在方法里只能用dataset,在这个全面组件化的大环境下居然不支持组件化… 其实最开始主要是书写时习惯的问题，秉承着我又不做小程序开发，就先忍着你的态度放任不管了。然而天有不测风云，最近因为业务的需求不得不做小程序相关的开发，我就倔脾气果断就不能忍了。果断的把不爽的地方改成能按我喜欢的方式来走，其中还遇到了一些其他的坑，一个个慢慢填，并把这些记录下来整理成了这篇文章。 网络请求网络请求小程序提供了wx.request，这个是我最想吐槽的点, 仔细看一下 api，这货不就是n年前的$.ajax吗，好古老啊。 1234567891011121314// 官方例子wx.request(&#123; url: 'test.php', //仅为示例，并非真实的接口地址 data: &#123; x: '' , y: '' &#125;, header: &#123; 'content-type': 'application/json' // 默认值 &#125;, success: function(res) &#123; console.log(res.data) &#125;&#125;) 现在还是只有一个请求就已经感觉写的很长了，如果一个页面需要多个请求呢，如果请求的顺序还有要求呢该怎么办，各种嵌套又臭又长，如果要求所以请求都完成之后再显示界面呢 瞬间懵逼。 这个时候我弱弱的看了一眼小程序的JS版本的支持，欧耶，比较良心的支持ES6。也就是说我们可以将其改成Promise是可能的。接下来看我如何改造。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* utils/api.js 自定义网络请求 */const baseURL = 'https://yourapi.com' // 自己后台API地址const http = (&#123; url = '', params = &#123;&#125;, ...other&#125; = &#123;&#125;) =&gt; &#123; wx.showLoading(&#123; title: '加载中...' &#125;) let time = Date.now() console.log(`开始:$&#123;time&#125;`) return new Promise((resolve, reject) =&gt; &#123; wx.request(&#123; url: getUrl(url), data: params, header: getHeader(), ...other, complete: (res) =&gt; &#123; wx.hideLoading() console.log(`耗时:$&#123;Date.now() - time&#125;`) if (res.statusCode &gt;= 200 &amp;&amp; res.statusCode &lt; 300) &#123; resolve(res.data) &#125; else &#123; reject(res) &#125; &#125; &#125;) &#125;)&#125;const getUrl = url =&gt; &#123; if (url.indexOf('://') == -1) &#123; url = baseURL + url &#125; return url&#125;const getHeader = () =&gt; &#123; try &#123; var token = wx.getStorageSync('token') if (token) &#123; return &#123; 'token': token &#125; &#125; return &#123;&#125; &#125; catch (e) &#123; return &#123;&#125; &#125;&#125;module.exports = &#123; baseURL, get (url, params = &#123;&#125;) &#123; return http(&#123; url, params &#125;) &#125;, post(url, params = &#123;&#125;) &#123; return http(&#123; url, params, method: 'post' &#125;) &#125;, put(url, params = &#123;&#125;) &#123; return http(&#123; url, params, method: 'put' &#125;) &#125;, // 这里不能使用 delete, delete为关键字段 myDelete(url, params = &#123;&#125;) &#123; return http(&#123; url, params, method: 'delete' &#125;) &#125;&#125; 接了下来我们就可以正常的时候用了，写一下简单的例子吧 123456789101112131415161718const api = require('../../utils/api.js')// 单个请求api.get('list').then(res =&gt; &#123; console.log(res)&#125;).catch(e =&gt; &#123; console.log(e)&#125;)// 一个页面多个请求Promise.all([ api.get('list'), api.get(`detail/$&#123;id&#125;`)]).then(result =&gt; &#123; console.log(result)&#125;).catch(e =&gt; &#123; console.log(e)&#125;) 如果习惯了 fetch 以及 axios 的朋友应该都会比较喜欢这种写法。 在做网络请求的时候还遇到一个问题，登录授权的问题。 登录问题做一个应用，肯定避免不了登录操作。用户的个人信息啊，相关的收藏列表等功能都需要用户登录之后才能操作。一般我们使用token做标识。然后又会涉及到token不存在,用户第一次登录，token过期后，重新登录等问题。比较常规的操作是直接跳转到登录页面。 然后坑就出现了，小程序并没有登录界面，使用的是 wx.login。wx.login 会获取到一个 code，拿着该 code 去请求我们的后台会最后返回一个token到小程序这边，保存这个值为 token 每次请求的时候带上这个值。（详情可以查看小程序登录。） 然而仅仅这样就够了吗？ 很显然并不是。一般还需要把用户的信息带上比如用户微信昵称，微信头像等，这时候就需要使用 wx.getUserInfo,这里涉及到一个用户授权的问题，留一个坑接下来再解决。带上用户信息就够了嘛？ too young too simple！我们的项目不可能只有小程序，相应的微信公众平台可能还有相应的App，我们需要把账号系统打通，让用户在我们的项目中的账户是同一个。这就需要用到微信开放平台提供的 UnionID。 ps.基于小程序在微信中的易传播性, 为了鼓励用户去传播分享一般还会提供邀请奖励机制。但是微信这边又会对诱导分享进行和谐处理。视情况慎用。（本文会在例子上加上该功能） 看到这，是不是觉得头都大了，就一个小小的登录功能坑这么多。 年轻的我瑟瑟发抖~~~。慢慢开始填吧。先上登录代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* utils/api.js 自定义网络请求 */...function login() &#123; return new Promise((resolve, reject) =&gt; &#123; // 先调用 wx.login 获取到 code wx.login(&#123; success: res =&gt; &#123; // 再调用 wx.getUserInfo 获取到用户的一些信息 （一些基本信息，以及生成UnionID 所用到的信息 比如 rawData, signature, encryptedData, iv） wx.getUserInfo(&#123; // 若获取不到用户信息 （最大可能是用户授权不允许，也有可能是网络请求失败，但该情况很少） fail: (e) =&gt; &#123; reject(e) &#125;, success: (&#123; rawData, signature, encryptedData, iv &#125;) =&gt; &#123; let param = &#123; code: res.code, rawData, signature, encryptedData, iv &#125; // 若有邀请ID try &#123; let invite = wx.getStorageSync('invite') if (invite) &#123; param.invite = invite &#125; &#125; catch (e) &#123; &#125; // 登录操作 http(&#123; url: 'login', params: param, method: 'post' &#125;).then(res =&gt; &#123; // 该为我们后端的逻辑 若code &gt; 0为登录成功，其他情况皆为异常 （视自身情况而定） if (res.code &gt; 0) &#123; // 保存用户信息 wx.setStorage(&#123; key: 'userinfo', data: res.data &#125;) wx.setStorage(&#123; key: "token", data: res.message, success: () =&gt; &#123; resolve(res) &#125; &#125;) &#125; else &#123; reject(res) &#125; &#125;).catch(error =&gt; reject(error)) &#125; &#125;) &#125; &#125;) &#125;)&#125;... 授权问题根据上面的代码，可以很清楚的看到，若用户在登录的时候不允许小程序获取他的用户信息之后才能继续。若用户在这个时候点拒绝了呢, 会怎么样？一片空白!~~ What’s the fuck! 怎么什么都没有！垃圾破小程序~~ 冷静点的用户也会百脸懵逼状。我是谁？我该怎么办？也许你会觉得，用户点允许就好了啊，怎么会这么笨，这种用户肯定不会多之类的话。我在我们小程序中加了统计大约有 20%的用户点了拒绝, 如果后续我们没有做任何引导的话，这 20% 的用户就会永远失去。这个后果我们完全不能接受。 经过我们的小组研究与讨论，给出了一下的一套方案。 具体代码可以如下表示，用到了 wx.openSetting 来跳转到设置授权界面。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* index.js */// 若有用户信息存在则继续Page(&#123; onLoad () &#123; wx.getStorage(&#123; key: 'userinfo', success: (res) =&gt; &#123; this.setUserinfo(res) &#125;, fail: (res) =&gt; &#123; api.login().then((res) =&gt; &#123; this.setUserinfo(res) &#125;).catch(e =&gt; &#123; if (e.errMsg &amp;&amp; e.errMsg === 'getUserInfo:fail auth deny') &#123; this.setData(&#123; isauth: false &#125;) &#125; &#125;) &#125; &#125;) &#125;, toSetting() &#123; wx.openSetting(&#123; success: (res) =&gt; &#123; this.setData(&#123; isauth: res.authSetting['scope.userInfo'] &#125;) if (res.authSetting['scope.userInfo']) &#123; api.login().then((res) =&gt; &#123; this.setUserinfo(res) &#125;) &#125; &#125; &#125;) &#125;&#125;)// setUserinfo 就是对用户信息做一下处理 不具体展开了/* index.wxml */&lt;view class="unauth" wx:if="&#123;&#123;!isauth&#125;&#125;"&gt; &lt;image class="unauth-img" src="../../images/auth.png"&gt;&lt;/image&gt; &lt;text class="unauth-text"&gt;检查到您没打开授权&lt;/text&gt; &lt;button class="color-button unauth-button" bindtap="toSetting"&gt;去设置&lt;/button&gt;&lt;/view&gt;&lt;view class="container" wx:else&gt;...&lt;/view&gt; token 失效问题登录获取到的 token 是有时效的，失效过了会怎么样 ? 如果后台小伙伴严格按照 REST API 规范设计接口 API 的话，他会给我们返回一个错了 http code 为 401。（常见的Http Code以及相关代码的意义本文就不做展开了，不了解的小伙伴可以自行 google 百度一下。）401 之后我们就需要对该Code进行相应的处理。可以如下这么写 1234567891011api.get('list').then(res =&gt; &#123; /* do something */&#125;).catch(e =&gt; &#123; if (res.statusCode === 401) &#123; api.login().then(() =&gt; &#123; api.get('list').then(res =&gt; &#123; /* do something */ &#125;) &#125;) &#125;&#125;) 看起来没什么问题，也完成需求了。但是会发现这有很大的问题。 每个请求都需要加 401 的判断，项目大起来 这块的代码量是非常恐怖的 接口返回的之后的处理 /* do something */ 也是重复的 （当然把这整块内容都提取出来，这里就调用也行。不过还是想把调用这边也省略掉 ^-^ ） 屡一下我们要实现的目标。 需要在每个请求后面都加一个 401 的判断 若未授权 则进行重新登录 重新登录之后继续前一个请求 将该请求结果返回到第一个请求的结果里去（实现无感知重新登录获取信息） 这个体现出把自己封装一个网络请求的好处, 我们可以直接改写 api.js 中的 http 方法里对 error 的处理就好。上代码： 1234567891011121314151617181920212223242526272829303132const http = (&#123; url = '', params = &#123;&#125;, ...other&#125; = &#123;&#125;) =&gt; &#123; wx.showLoading(&#123; title: '加载中...' &#125;) let time = Date.now() console.log(`开始:$&#123;time&#125;`) return new Promise((resolve, reject) =&gt; &#123; wx.request(&#123; url: getUrl(url), data: params, header: getHeader(), ...other, complete: (res) =&gt; &#123; wx.hideLoading() console.log(`耗时:$&#123;Date.now() - time&#125;`) if (res.statusCode &gt;= 200 &amp;&amp; res.statusCode &lt; 300) &#123; resolve(res.data) &#125; else if (res.statusCode === 401) &#123; // 401 为鉴权失败 很大可能是token过期 // 重新登录 并且重复请求 login().then(res =&gt; &#123; http(&#123; url, params, ...other &#125;).then(res =&gt; &#123; resolve(res) &#125;) &#125;) &#125; else &#123; reject(res) &#125; &#125; &#125;) &#125;)&#125; 小结网络请求这块，算目前开发项目中必不可少的一块。但是例如 小程序，vue, react, weex 等其实都有一套自己的或者自己推荐的一套API以及相应的写法。没一个都按照他推荐的来写，其实挺蛋疼的，用着很不爽。把他们的API封装一下，暴露出来统一的API, 给自己用或者尤其是给自己团队的小伙伴用就比较方便，少了很多重复学习成本，并且因为统一的API带来的统一的格式也是很大的一个好处。 说到小程序要弄清楚的东西不少，有些坑我还在摸索怎么处理。比如小程序的组件化，全局变量的使用（什么值可以放在app.js里），html标签的转换等，后续弄透了我会再出来献丑的。 (^ _ ^) 上一篇文章获得了 484的喜欢 200多人的关注 其实我挺开心的。比起大神来说可能很少, 但是对于一个很难下定决心才开始写博客的人来说，给了我很大的鼓舞，谢谢~]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>产出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署网站我们前端不求人]]></title>
    <url>%2F2018%2F04%2F27%2F%E9%83%A8%E7%BD%B2%E7%BD%91%E7%AB%99%E6%88%91%E4%BB%AC%E5%89%8D%E7%AB%AF%E4%B8%8D%E6%B1%82%E4%BA%BA%2F</url>
    <content type="text"></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>产出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端适配问题解决方案]]></title>
    <url>%2F2018%2F04%2F19%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[前言随着时间的发展，现在基本上人手一部手机的低头族。做为前端开发的程序猿，在开发移动端web应用的时候，对面一堆各色尺寸不一样的屏幕，就有点淡淡的忧伤。已上是2018年二月份最新的友盟数据，可在这里查看详情 很明显我们所要实现的就是在上述如此之多的屏幕,都能实现UI大大出的视觉图上的效果。而要实现这样的效果主要有两个难点 各屏幕适配 Retina屏下的细节处理（主要是1px的问题） 各屏幕适配各屏幕的适配，有两种方案，flexible + rem 与 vw。这三个单词是什么意思，看着很眼熟，但是这两个方案居然是什么呢,请允许我细细道来。 flexible + rem显而易见,该方案是由rem 以及 flexible组成的。rem （font size of the root element）相对于根元素(即html元素)font-size计算值的倍数,flexible 即 flexible.js, 手淘团队提供的一个为该方案屏幕适配而写的一个库,主要实现的功能就是，根据屏幕的宽度给 html 元素设置一个合适的 font-size 值。 怎么样看的不是很懂是吧。让我来用一个页面场景再复述一遍。 正常情况下，我们的UI大大会以iphone6的尺寸为标准，做一套视觉效果图，并在上面进行标注，给到我们的标注图，如下所示 拿到这个图 我们该如何下手呢 先设置 html 元素的 font-size, 这个值我们暂时设置为 font-size: 37.5px，即1rem = 37.5px; 以iphone6为例子，其屏幕宽度为 750px, 整个屏幕的宽度即 20rem = 37.5 * 20px = 750px; 此时手机号的输入框为 490px = 13.06777777rem 依次将页面上的px转换为rem，这样我们就得到了全是rem为尺寸单位的页面 到这里为止是不是就结束了呢 ? 很遗憾的告诉你并不是。为什么 html 元素的 font-size 要设置为 37.5px呢？现在这个界面在iphone6上能完美显示了，在iphone5s,iphone6p能完美显示吗？（iphone6, iphone6s, iphone7. iphone8屏幕没有发生变化，本文直接用iphone6代替了。）上面的两个问题 我们还有没解决，这个时候就轮到flexible登场了。只需要像如下引入就可实现用js来自动根据屏幕宽度设置 html元素的font-size的值。 1&lt;script src=&quot;http://g.tbcdn.cn/mtb/lib-flexible/0.3.4/??flexible_css.js,flexible.js&quot;&gt;&lt;/script&gt; 引申一下在上述过程中，你会发现，UI给到我们的一般是px标注的图，我们将其转化为rem，这个过程其实会花费很大的计算时间。做为一个合格的程序员，我们应该把这种机械性无脑的操作交给计算机来实现。我使用的是PostCss的插件 postcss-px2rem,这个插件能让我们在写代码时候直接写px，在构建的时候自动将我们所写的px转换为rem，大大提升了我们的开发效率。 vw这个vw的方案，相当而言还比较新。vw 即（viewport width）可视窗口的宽度。之所以把这个方案放在后面来说，是因为viewport在去年（2017年）的时候存在不少的兼容性问题，各个浏览器的支持并不是很好。但是来到了2018年这个时间点，viewport单位意见得到了众多浏览器的支持（80.45%）。可以在这里查看。 接下来就让我们来正式了解下这个方案吧。vw既然是一个尺寸单位，那它的宽度等于多少呢？等于1%整个屏幕的宽度。举个例子，再次以iphone6手机为例，100vw = 750px =&gt; 1vw = 7.5px 再一次那上次的界面做示范 根据定义，我们了解了在iphone6手机上 1vw = 7.5px 此时手机号的输入框为 490px = 65.333333vw 依次将页面上的px转换为vw，这样我们就得到了全是vw为尺寸单位的页面 到这里为止是不是就结束了呢? 是的就是这么简单。 引申一下跟之前一样的痛点，我们仍然需要花费大量不必要的计算时间去把标注图中的px转换为vw，有没有类似于postcss-px2rem的工具呢？很荣幸能再次站在巨人的肩膀上，已经有大神写了了类似的PostCss插件 postcss-px-to-viewport 1px问题移动端的屏幕不仅仅分辨率有差异，其实还有Retina屏的问题。正常情况下，我们代码里的1px在屏幕上就应该显示一个像素点，但是在Retina屏下则不仅仅是一个像素点。再次拿iphone6为例，其dpr(device pixel ratio)设备像素比为2，css中一个1x1的点，其实在iphone6上是2x2的点,并且1px的边框在devicePixelRatio = 2的Retina屏下会显示成2px，在iPhone6 Plus下甚至会显示成3px。 这样的话，我们就会发现在有些手机上1px明显跟另外的一些手机的1px粗细不一样。其实大多数的小公司不会扣这样的一个细节，比如说我们公司不会。(^__^) 嘻嘻…… 但是作为一个有追求的前端工程师，我们应该尽量的把事情做的完美一点，（ps.像大公司看齐，在大公司这个细节问题其实是不容忽视的，为了自己以后的发展前途，我们有必要把这个细节完善掉的。） 这个问题的解决方案有很多，个人觉得最简单方面的还是大漠大大的一种解决方案。使用postcss-write-svg插件, 1234567891011@svg 1px-border &#123; height: 2px; @rect &#123; fill: var(--color, black); width: 100%; height: 50%; &#125; &#125;.example &#123; border: 1px solid transparent; border-image: svg(1px-border param(--color #00b1ff)) 2 2 stretch;&#125; 编译出来就是 1234.example &#123; border: 1px solid transparent; border-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' height='2px'%3E%3Crect fill='%2300b1ff' width='100%25' height='50%25'/%3E%3C/svg%3E") 2 2 stretch;&#125; 其他小程序中的屏幕适配最近在写小程序，在小程序里，使用的是小程序的那套，跟平时用的vue全家桶以及react全家桶不一样，并没有配置webpack，在这种情况下我们使用postcss其实很困难（反正我是搞不出来/(ㄒoㄒ)/~~） 那该怎么办呢，小程序提供了一个自己的单位, rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。 设备 rpx换算px (屏幕宽度/750) px换算rpx (750/屏幕宽度) iPhone5 1rpx = 0.42px 1px = 2.34rpx iPhone6 1rpx = 0.5px 1px = 2rpx iPhone6p 1rpx = 0.552px 1px = 1.81rpx 我们直接用拿到iphone6的标注图，直接写rpx就好。棒👍 总结如果仔细看一下的话，会发现之前的rem的方案其实就是模拟了vw的实现方案，两者有非常多的相似之处。在lib-flexible的github上有着这样的一句话。 由于viewport单位得到众多浏览器的兼容，lib-flexible这个过渡方案已经可以放弃使用，不管是现在的版本还是以前的版本，都存有一定的问题。建议大家开始使用viewport来替代此方案。vw的兼容方案可以参阅《如何在Vue项目中使用vw实现移动端适配》一文。 我们可以得到一个很明确的信息，lib-flexible这个方案已经被放弃使用了，我们可以去拥抱vw的那套实现方案。 本文参考了大漠大大在 www.w3cplus.com 里的多篇文章 使用Flexible实现手淘H5页面的终端适配 再聊移动端页面的适配 走向视网膜（Retina）的Web时代 再谈Retina下1px的解决方案 小程序-wxss]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>产出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript设计模式阅读笔记]]></title>
    <url>%2F2018%2F04%2F03%2FJavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言遇到一个问题，给别人解释一个东西,经常要讲一堆，讲完之后得到一个回复，那不是就是xx模式吗。 “模式”取名的意义非常重要。人类可以走到生物链顶端的前两个原因分别是会“使 用名字”和“使用工具”。在软件设计中，一个好的设计方案有了名字之后，才能被更好地传播， 人们才有更多的机会去分享和学习它们。也许这个小故事可以说明名字对于模式的重要性:假设你是一名足球教练，正在球场边指挥 一场足球赛。通过一段时间的观察后，发现对方的后卫技术精湛，身体强壮，但边后卫速度较慢， 中后卫身高和头球都非常一般。于是你在场边大声指挥队员:“用速度突破对方边后卫之后，往 球门方向踢出高球，中路接应队员抢点头球攻门。”在机会稍纵即逝的足球场上，教练这样费尽口舌地指挥队员比赛无疑是荒谬的。实际上这种 战术有一个名字叫作“下底传中”。正因为战术有了对应的名字，在球场上教练可以很方便地和 球员交流。“下底传中”这种战术即是足球场上的一种“模式”。 设计模式的主题总是把不变的事物和变化的事物分离开来 不同的设计模式就是在不同的场景下实现把不变的事物和变化的事物分离开来的解决方案总结 基础知识学习发现两个好玩的方法 includes 是否包含Array.prototype.includes(), String.prototype.includes() 分别在 ES2016 与 ES2015 中支持，部分浏览器有兼容问题 1234let arr = [1,2,3,4,'5']console.log(arr.includes('5')) // truelet str = 'hello world'console.log(str.includes('world')) // true in 指定的属性是否在指定的对象或其原型链中123456let person = &#123; name: 'duke' &#125;let boy = Object.create(person)boy.age = '18'console.log('age' in boy) // true; boy 对象本身的属性console.log('name' in boy) // true; boy 原型链上父类 person的属性console.log('sex' in boy) // false; 在boy以及其原型链上并没有 sex 闭包闭包是JS的一大重点，主要有以下作用 封装变量 延续局部变量的寿命 高阶函数 AOP AOP(面向切面编程)的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些 跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来之后， 再通过“动态织入”的方式掺入业务逻辑模块中。这样做的好处首先是可以保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块。 currying &amp; uncurrying currying 又称部分求值。一个 currying 的函数首先会接受一些参数，接受了这些参数之后， 该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保 存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。 函数节流 JavaScript 中的函数大多数情况下都是由用户主动调用触发的，除非是函数本身的实现不合 理，否则我们一般不会遇到跟性能相关的问题。但在一些少数情况下，函数的触发不是由用户直接控制的。在这些场景下，函数有可能被非常频繁地调用，而造成大的性能问题。window.onresize 事件、mousemove 事件、上传进度 … 频繁调用的函数，设置一个setTimeout延迟一段时间执行，若上一个延迟执行还没有结束则忽略接下来该函数的调用。 分时函数 某些函数确实是用户主动调用的，但因为一些客观的原因，这些函数会严 重地影响页面性能。比如直接渲染一个1000+条长列表时，可能会造成页面卡顿甚至未响应。 惰性加载函数 单一职责原则设计模式单例模式 单例模式的定义是:保证一个类仅有一个实例，并提供一个访问它的全局访问点。 12345678910111213var createLoginLayer = (function()&#123; var div; return function()&#123; if (!div)&#123; div = document.createElement( 'div' ); div.innerHTML = '我是登录浮窗'; div.style.display = 'none'; document.body.appendChild( div ); &#125; return div; &#125;&#125;)();console.log(createLoginLayer() === createLoginLayer()) // true 上述方法的确可以创建一个单例，但是其实际上包含了两个职责，管理单例与创建对象。如果我们仅需要创建对象或者要复用管理单例的话，其实是做不到的或者就需要全部重新写。根据单一职责原则我们可以把上述代码进行如下拆分。 123456789101112131415161718// 将普通实例方法转化为单例var getSingle = function( fn )&#123; var result; return function()&#123; return result || ( result = fn.apply(this, arguments) ); &#125;&#125;;// 创建登录界面var createLoginLayer = function()&#123; var div = document.createElement( 'div' ); div.innerHTML = '我是登录浮窗'; div.style.display = 'none'; document.body.appendChild( div ); return div;&#125;;// 创建登录界面单例var createSingleLoginLayer = getSingle( createLoginLayer );console.log(createSingleLoginLayer() === createSingleLoginLayer()) // true 策略模式 策略模式的定义是:定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。 计算年终奖金12345678910111213var calculateBonus = function( performanceLevel, salary )&#123; if ( performanceLevel === 'S' )&#123; return salary * 4; &#125; if ( performanceLevel === 'A' )&#123; return salary * 3; &#125; if ( performanceLevel === 'B' )&#123; return salary * 2; &#125;&#125;;calculateBonus( 'B', 20000 ); // 输出:40000calculateBonus( 'S', 6000 ); // 输出:24000 可以显而易见发现一些缺点 calculateBonus类很复杂，包含了很多的if-else calculateBonus缺乏弹性，若要增加一个C类或者修改S类的系数，则需要修改calculateBonus函数的内部实现，违反了开发-封闭原则。 复用性太长，若在其他地方有用到这些奖金算法,只能复制黏贴过去。 12345678910111213141516var strategies = &#123; "S": function( salary )&#123; return salary * 4; &#125;, "A": function( salary )&#123; return salary * 3; &#125;, "B": function( salary )&#123; return salary * 2; &#125;&#125;;var calculateBonus = function( level, salary )&#123; return strategies[ level ]( salary );&#125;;console.log( calculateBonus( 'S', 20000 ) ); // 输出:80000console.log( calculateBonus( 'A', 10000 ) ); // 输出:30000 表单验证12]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS-new]]></title>
    <url>%2F2018%2F04%2F03%2FJS-new%2F</url>
    <content type="text"><![CDATA[JS中并没有类的概念,但是经常性会看到 var test = new Test(&#39;duke&#39;) 这样的写法。很像java里构造实例的方式。 123456789101112131415161718// ES5function Test(name) &#123; this.name = name&#125;// 等价于function Test(name) &#123; var obj = Object.create(Test.prototype) obj.name = name return obj&#125;// ES6class Test &#123; constructor (name) &#123; this.name = name &#125;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weex快速开发三端应用：做一个看书软件]]></title>
    <url>%2F2018%2F03%2F20%2FWeex%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E4%B8%89%E7%AB%AF%E5%BA%94%E7%94%A8%EF%BC%9A%E5%81%9A%E4%B8%80%E4%B8%AA%E7%9C%8B%E4%B9%A6%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[小册内容 [ ] 1.weex 基本原理 [ ] 2.weex 脚手架的使用 [ ] 3.weex 的一些基本组件 [ ] 4.搭建第一个 weex 页面 [ ] 5.推荐书籍页 &amp; 网络请求 [ ] 6.我的书架 &amp; 本地缓存 [ ] 7.书籍目录 &amp; 长列表处理 [ ] 8.页面之间传值 [ ] 9.真机运行与调试 [ ] 10.云打包工具 —— 轻舟 [ ] 11.小结 什么是 Weex ？ Weex 是一个使用 Web 开发体验来开发高性能原生应用的框架。 Weex 致力于使开发者能基于当代先进的 Web 开发技术，使用同一套代码来构建 Android、iOS 和 Web 应用。具体来讲，在集成了 WeexSDK 之后，你可以使用 JavaScript 和现代流行的前端框架来开发移动应用。 Weex 的结构是解耦的，渲染引擎与语法层是分开的，也不依赖任何特定的前端框架，目前主要支持 Vue.js 和 Rax 这两个前端框架。 VueVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。目前主流的三大框架之一，本小册就是用的 Vue 框架开做 Weex 的语法层。详情可参阅这里。 RaxRax 是一个兼容 React 接口的前端框架。详情可参阅这里。 为什么要学 Weex？写过H5的同学肯定会被它的简单高效、发布即更新、一条URL可适配多端等这些快所吸引，但写过 Native 的同学肯定也会被 Native 的富交互、性能体验、可调用原生能力、可管理内存等特性给我们的业务带来更好的体验。 快与体验兼得 你会学到什么？ weex 基本原理 weex 脚手架的使用 weex 基本组件的使用 weex 的网页调试&amp;真机调试 实战中遇到的一些坑以及相应的解决方案 你需要准备什么？需要你懂一些HTML, CSS 与 JS 的基础，因为本课程是使用 Vue 来做 weex 的语法层，如果你有一定的 Vue 基础，你将更好的学习。 一台移动设备（Android或者iOS手机） 一台可以联网的电脑 还需要一点点的前端基础 购买须知 本小册为图文形式内容服务，共计 11 节； 购买用户可享有小册永久的阅读权限； 购买用户可进入小册微信群，与作者互动； 掘金小册为虚拟内容服务，一经购买成功概不退款； 掘金小册版权归北京北比信息技术有限公司所有，任何机构、媒体、网站或个人未经本网协议授权不得转载、链接、转贴或以其他方式复制发布/发表，违者将依法追究责任； 在掘金小册阅读过程中，如有任何问题，请邮件联系 xiaoce@xitu.io]]></content>
      <categories>
        <category>小册子</category>
      </categories>
      <tags>
        <tag>小册子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue相关知识点]]></title>
    <url>%2F2018%2F02%2F01%2Fvue%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Vue的整体机制 主要流程为 初始化及挂载 =&gt; 编译 =&gt; 响应式 =&gt; Virtual DOM =&gt; 更新视图 初始化及挂载new Vue()的时候,Vue会调用一个 _init 函数，它会初始化Vue的生命周期、事件、data等，其中最重要的是通过 Object.defineProperty 设置 setter 与 getter 函数，来实现[响应式]以及[依赖收集]。 初始化之后会调用 $mount 函数挂载组件，如果是运行时编译，即不存在 render function 但是存在 template 的情况，需要进行[编译]步骤。 编译]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>思考</tag>
        <tag>知识点整理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本知识]]></title>
    <url>%2F2018%2F01%2F31%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[基本定义一级函数在 JavaScript 中，函数是一级函数。这意味着，就像对象一样，你可以像处理其他元素（如数字、字符串、数组等）一样来处理函数。JavaScript 函数可以： 1.存储在变量中。2.从一个函数返回。3.作为参数传递给另一个函数。 高阶函数返回另一个函数的函数 与 具有函数参数的函数 被称为高阶函数。 12345678910111213function test () &#123; return function () &#123; &#125;&#125;function test1 () &#123;&#125;function test2 (callback) &#123; callback()&#125;test2(test1) 回调函数作为参数传递给另一个函数的函数被称为回调函数。 闭包 函数保留对其作用域的访问的这个过程被称为闭包 闭包的作用 隐含地传递参数。在函数声明中，存储作用域的快照。 123456789function remember(number) &#123; return function() &#123; return number; &#125;&#125;const returnedFunction = remember(5);console.log( returnedFunction() ); // 打印数字 5 立即调用函数表达式立即调用函数表达式或 IIFE（发音为 iffy）是在定义之后立即被调用的函数。 新单词instanceof constructor]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[失败经验总结]]></title>
    <url>%2F2018%2F01%2F31%2F%E5%A4%B1%E8%B4%A5%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[下次每次电话面试都记得录音 ···一直觉得阿里的前端是前端这边的标杆。希望能以阿里的前端为标准要求自己，自己进步并跟上步伐。最近一次阿里的面试是目前数次阿里面试中，面试次数最多的一次，也发现了更多自己的不足。 面试经历一面（电话面）聊了不少，半个小时左右。 1.vue-router实现原理2.vuex实现原理3.浏览器渲染机制4.各个浏览器内核以及兼容问题5.移动端适配 二面（现场面）二面的时候比较轻松 1.为什么用vue2.遇到难点3.自己满意的点4.weex 三面（电话面）—— 跪了三面的时候十分紧张,脑袋有点秀逗 vue相关 1.Vue双向绑定原理2.vue-router实现原理3.vue list中 子元素 绑定事件4.vue中列表 下一页之后返回上一页是否重新加载视图 weex相关1.weex实现基本原理2.weex的不足3.weex中的渲染机制 JS/css 1.点击事件 浏览器兼容问题2.移动事件 ontouchmove 以及优化 事件节流比如首先生成一个 独立 重绘的BFC渲染层。然后通过 CSS的相关动画来 控制dom的移动而不是通过JS直接修改 DOM 的位置。在往下就是 通过requestAnimationFrame来优化渲染 放入队列中 固定时间执行一次 3.动画卡顿的问题这个问题应该问的的浏览器渲染以及重绘方面的问题，主要包括以下五个步骤正常情况下可分为三种情况,Javascript 与 Style 必不可少的 1.Layout Paint Composite; margin, padding, height等改变布局的 2.Paint Composite; color等不改变布局只改变样式的 3.Composite; opacity,transform等只改变图层的 具体可以参照这里 ps. 可以引入 60帧/s 即一帧在16ms内完成才能回不造成卡顿，实际情况下浏览器处理仍然需要实际，故要将每帧动画控制在10ms左右 再ps. setTimeout, setInterval 与 requestAnimationFrame使用 requestAnimationFrame 能将 javascript 放在每帧的最开始的时候，避免了中途重绘、丢帧的情况(requestAnimationFrame 在 IE9 浏览器中不支持 可以使用 polyfill会使用setTimeout替代) 4.翻页动效 实现 其他1.最新信息/技术 获取以及了解微信公众号,知乎, 掘金，segmentfault,V2EV, 2.自己的优势以及发展工作五年一直做的事情都是偏业务的，不是一个技术极客，就目前而言的所学的技术都是跟随者业务来走的，jsp + servlet =&gt; 前后端分离 =&gt; 工程化开发，Vue SSR 因为有SEO方面的需求，小公司的的需求敏捷开发，快速迭代 =&gt; 制作了一个能快速开始项目的脚手架，一个简单的组件库，weex一套代码 三端通用。业务方面不仅仅在技术上实现就好，需要跟运营，市场，产品沟通也是非常重要的。在这方面我比较多的经验。开发前明确捕捉到真正的需求，能大大的增加开发效率以及减少后续的返工·比如说后台管理系统以及一些内部的系统，在美观以及动效等方面其实没有太多的需求，对于数据，图表有着比较大的要求，而在to C 的web应用上对用户体验，动效等方面要求就比较好·未来可能会往管理岗位发展，就本人的工作经历而已其实涵盖了技术开发的很多方面，有便于多方协调，本人的性格方面也挺适合。不足的是，目前主要的手段是和事老以及兜底，目前重心还是会放在技术上，争取在前端方向发展出了什么样的问题 都能完美的兜底。 3.不用框架 你做过什么 4.webpack loader 与 pluginloader 用于加载某些资源文件。plugin 用于扩展webpack的功能。 总结 [x]1.深入了解下Vue的相关原理以及实现(vue, vue-router, vuex) [ ]2.自己写一个简单MVVM框架 [ ]3.Webpack相关的知识点再复习一遍 [ ]4.自己着手写一下 loader 以及 plugin [ ]5.浏览器渲染机制 [ ]6.css3动画 [ ]7.weex相关的原理以及实现 再加最新信息 [ ]8.总结优势]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密算法(一) —— 对称加密]]></title>
    <url>%2F2017%2F09%2F18%2F%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[前言web前端这个概念其实是在近几年才突出出来！它的前身其实就是传说中的切图工(把UI出的图切出来放在对的地方就好)。前后端分离后, web前端要承当的是事情变的越来越多,代码量也越变越大。前端工程化,构建编译,加密… 近期在整理web前端用到的一些加密技术以及相关的工具。 对称加密算法 (DES、3DES、AES)1.简介1.1 定义对称加密算法是应用较早的加密算法，技术成熟。在对称加密算法中，数据发信方将明文（原始数据）和加密密钥（mi yue）一起经过特殊加密算法处理后，使其变成复杂的加密密文发送出去。收信方收到密文后，若想解读原文，则需要使用加密用过的密钥及相同算法的逆算法对密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密，这就要求解密方事先必须知道加密密钥。 1.2 优缺点 优点：算法公开、计算量小、加密速度快、加密效率高。缺点：（1）交易双方都使用同样钥匙，安全性得不到保证。（2）每对用户每次使用对称加密算法时，都需要使用其他人不知道的惟一钥匙，这会使得发收信双方所拥有的钥匙数量呈几何级数增长，密钥管理成为用户的负担。对称加密算法在分布式网络系统上使用较为困难，主要是因为密钥管理困难，使用成本较高。 1.3 常用对称加密算法基于“对称密钥”的加密算法主要有DES、3DES（TripleDES）、AES、RC2、RC4、RC5和Blowfish等。比较常用的对称加密算法基本上就 DES、3DES（TripleDES）和AES。 DES（Data Encryption Standard）3DES（DES加强版，使用3次DES计算，Triple DES，DESede）AES（Advanced Encryption Standard，3DES加强版） 2.分组模式2.1 EBC模式 优点：1.简单；2.有利于并行计算；3.误差不会被传送； 缺点：1.不能隐藏明文的模式；2.可能对明文进行主动攻击。 2.2 EBC模式 —— 密码分组链接模式 优点：1.不容易主动攻击,安全性好于ECB,适合传输长度长的报文,是SSL、IPSec的标准。 缺点：1、不利于并行计算；2、误差传递；3、需要初始化向量IV。 2.3 CFB模式 —— 密码发反馈模式 优点：1、隐藏了明文模式；2、分组密码转化为流模式；3、可以及时加密传送小于分组的数据。 缺点:1、不利于并行计算；2、误差传送：一个明文单元损坏影响多个单元；3、唯一的IV。 2.4 OFB模式 —— 输出反馈模式 优点：1、隐藏了明文模式；2、分组密码转化为流模式；3、可以及时加密传送小于分组的数据。 缺点：1、不利于并行计算；2、对明文的主动攻击是可能的；3、误差传送：一个明文单元损坏影响多个单元。 2.5 CTR模式 计数模式（CTR模式）加密是对一系列输入数据块(称为计数)进行加密，产生一系列的输出块，输出块与明文异或得到密文。对于最后的数据块，可能是长u位的局部数据块，这u位就将用于异或操作，而剩下的b-u位将被丢弃（b表示块的长度）。CTR解密类似。这一系列的计数必须互不相同的。假定计数表示为T1, T2, …, Tn。CTR模式可定义如下： CTR加密公式如下：Cj = Pj XOR Ek(Tj)Cn = Pn XOR MSBu(Ek(Tn)) j = 1，2… n-1; CTR解密公式如下：Pj = Cj XOR Ek(Tj)Pn = Cn XOR MSBu(Ek(Tn)) j = 1，2 … n-1; AES CTR模式的结构如下图所示 加密方式：密码算法产生一个16 字节的伪随机码块流，伪随机码块与输入的明文进行异或运算后产生密文输出。密文与同样的伪随机码进行异或运算后可以重产生明文。 CTR 模式被广泛用于 ATM 网络安全和 IPSec应用中，相对于其它模式而言，CRT模式具有如下特点：硬件效率：允许同时处理多块明文 / 密文。软件效率：允许并行计算，可以很好地利用 CPU 流水等并行技术。预处理：算法和加密盒的输出不依靠明文和密文的输入，因此如果有足够的保证安全的存储器，加密算法将仅仅是一系列异或运算，这将极大地提高吞吐量。随机访问：第 i 块密文的解密不依赖于第 i-1 块密文，提供很高的随机访问能力可证明的安全性：能够证明 CTR 至少和其他模式一样安全（CBC, CFB, OFB, …）简单性：与其它模式不同，CTR模式仅要求实现加密算法，但不要求实现解密算法。对于 AES 等加/解密本质上不同的算法来说，这种简化是巨大的。无填充，可以高效地作为流式加密使用。 3.填充模式进行DES、3DES和AES三种对称加密算法时，常采用的是NoPadding（不填充）、Zeros填充（0填充）、PKCS7Padding填充。 3.1 ZeroPadding 全部填充为0的字节，结果如下：F1 F2 F3 F4 F5 F6 F7 F8 //第一块F9 00 00 00 00 00 00 00 //第二块 3.2 PKCS7Padding 每个填充的字节都记录了填充的总字节数，结果如下：F1 F2 F3 F4 F5 F6 F7 F8 //第一块F9 07 07 07 07 07 07 07 //第二块 web前端实例 —— crypto-js没看错 就是web前端！ 本实例使用的 crypto-js。安装 crypto-js 是的简单 123npm install crypto-js -S// 或者yarn add crypto-js 实例 —— Triple DES1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import CryptoJS from &apos;crypto-js&apos;var str = &apos;123456&apos;var key = &apos;0123456789abcdef&apos;var iv = &apos;0123456789abcdef&apos; key = CryptoJS.enc.Utf8.parse(key)iv = CryptoJS.enc.Utf8.parse(iv) // DES 加密var encrypted = CryptoJS.DES.encrypt(str, key, &#123; iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7&#125;) // 转换为字符串encrypted = encrypted.toString() // DES 解密var decrypted = CryptoJS.DES.decrypt(encrypted, key, &#123; iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7&#125;) // 转换为 utf8 字符串decrypted = CryptoJS.enc.Utf8.stringify(decrypted) // Triple DES 加密var encrypted = CryptoJS.TripleDES.encrypt(str, key, &#123; iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7&#125;) // 转换为字符串encrypted = encrypted.toString() // Triple DES 解密var decrypted = CryptoJS.TripleDES.decrypt(encrypted, key, &#123; iv: iv, mode: CryptoJS.mode.CBC, padding: CryptoJS.pad.Pkcs7&#125;) // 转换为 utf8 字符串decrypted = CryptoJS.enc.Utf8.stringify(decrypted)]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>加密算法</tag>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为了以后的自己能偷懒]]></title>
    <url>%2F2017%2F09%2F06%2F%E4%B8%BA%E4%BA%86%E4%BB%A5%E5%90%8E%E7%9A%84%E8%87%AA%E5%B7%B1%E8%83%BD%E5%81%B7%E6%87%92%2F</url>
    <content type="text"><![CDATA[在项目开发的过程的经常会做一些重复的工作以及遇到一些类似的问题！ 特别在新开一个工程的时候！ API接口目前大部分的工程开发都已经做到了前后端分离。后端的小伙伴提供api接口,作为前端的我们使用ajax调用api接口获取数据，再渲染出相对应的界面！在实际的项目中，可能会遇到以下几个问题 前后端同步开发时, Mock的使用1234567891011121314151617181920212223242526272829303132const express = require(&apos;express&apos;)const router = express.Router()// 使用 Mockvar Mock = require(&apos;mockjs&apos;)router.get(&apos;/test&apos;, (req, res) =&gt; &#123; var data = Mock.mock(&#123; // 属性 list 的值是一个数组，其中含有 1 到 10 个元素 &apos;list|10&apos;: [&#123; // 属性 id 是一个自增数，起始值为 1，每次增 1 &apos;id|+1&apos;: 1, &apos;task_id|+1&apos;: 1, &apos;name|1&apos;: &apos;@cname()&apos;, &apos;time_begin&apos;: &apos;@datetime(&quot;yyyy-MM-dd HH:mm:ss&quot;)&apos;, &apos;time_end&apos;: &apos;@datetime(&quot;yyyy-MM-dd HH:mm:ss&quot;)&apos; &#125;] &#125;) res.json(&#123; code: 200, message: data &#125;)&#125;)router.get(&apos;*&apos;, (req, res) =&gt; &#123; res.json(&#123; code: -200, message: &apos;没有找到该页面&apos; &#125;)&#125;)module.exports = router 初始化模板 —— 后台管理篇1vue init 1xuanyuan1/admin-cli my-project]]></content>
      <categories>
        <category>全栈</category>
      </categories>
      <tags>
        <tag>组件</tag>
        <tag>偷懒</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SPA预渲染]]></title>
    <url>%2F2017%2F09%2F05%2FSPA%E9%A2%84%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[如果你要预呈现页面来更好地支持 SEO，使用 Webpack 插件：prerender-spa-plugin ，经过测试这是可以在 vue 中使用的。对于经常变动的页面，Prerender.io 和 Netlify 提供预呈现功能从而更好地支持搜索引擎。 SPA预渲染 —— 使用 prerender-spa-plugin1.安装插件1npm install --save-dev prerender-spa-plugin 或者1yarn add prerender-spa-plugin -D 2.在 build/webpack.prod.conf.js 文件中里使用1234567891011121314// 放在文件顶部var PrerenderSpaPlugin = require(&apos;prerender-spa-plugin&apos;)...plugins: [ new PrerenderSpaPlugin( // 要编译的目录 path.join(__dirname, &apos;../dist&apos;), // 你要预呈现的列表 [ &apos;/&apos; ] ) ...] 如果你想预呈现 /about 和 /contact，那么列表就是 [ ‘/‘, ‘/about’, ‘/contact’ ]]]></content>
      <categories>
        <category>全栈</category>
      </categories>
      <tags>
        <tag>预渲染</tag>
        <tag>prerender-spa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试问题小结]]></title>
    <url>%2F2017%2F08%2F30%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1.跨域介绍 为了保证使用者信息的安全，防止恶意网站篡改用户数据 只要协议、域名、端口有任何一个不同，都被当作是不同的域，之间的请求就是跨域操作 解决1).CORS（跨域资源访问）后端设置 Access-Control-Allow-Origin: origin | ‘‘ 允许某个指定的域访问，表示不限制域。 Access-Control-Allow-Methods: ‘GET,POST,PUT,DELETE’ 允许哪些类型的请求 Access-Control-Allow-Headers: ‘x-token’ 允许的自定义Header。 2).代理通过同源的api调用跨域的api, 服务端没有跨域的问题 3).jsonp2.CSRF和XSS XSS：跨站脚本（Cross-site scripting，通常简称为XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。 CSRF:跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。 很多同学会搞不明白XSS与CSRF的区别，虽然这两个关键词时常抱团出现，但他们两个是不同维度的东西（或者说他们的目的是不一样的）。XSS更偏向于方法论，CSRF更偏向于一种形式，只要是伪造用户发起的请求，都可成为CSRF攻击。 3.浏览器的渲染过程 DOM -&gt; CSSOM -&gt; render -&gt; layout -&gt; print 4.虚拟DOM、Diff算法、vuex和redux、weex和reactNative1).虚拟DOM把DOM存入内存, 不直接操作真实的DOM 先修改虚拟DOM 再把更改后的变化同步到真实DOM ps.虚拟DOM的推出 使weex &amp; reactNative等用JS写UI ios、Android或者web 负责渲染的方式让一套代码三端通用成功可能！ 2).Diff算法 在标准diff机制下：在同一位置对比前后的dom节点，发现节点改变了，会继续比较该节点的子节点，一层层对比，找到不同的节点，然后更新节点。 在react的diff算法下，在同一位置对比前后dom节点,只要发现不同，就会删除操作前的domm节点（包括其子节点），替换为操作后的dom节点。 在vue的diff算法下，有无设置key尽量不要跨层级的修改dom设置key可以最大化的利用节点不要盲目相信diff的效率，在必要时可以手工优化 5.常用的ES6 1.函数参数默认值2.模板字符串3.解构赋值4.对象属性简写5.箭头函数6.Promise7.Let与Const8.类9.模块化 6.SSR(服务端渲染) weexjs代码打包成bundle 然后用 各个端的渲染器来渲染相应的页面 7.遇到的问题，以及解决8.typescipt9.cancel request10.与后端配合前端比较倾向于展示所需要的数据, 后端比较倾向于输出模型相关的数据 两者其实是有冲突的常规的是前端拿到模型相关的数据 如果做数据清洗 转换为展示所需的数据 可以将数据清洗的部分抽取出来 做一个node的中间层]]></content>
      <categories>
        <category>小知识</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>小知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通往财富自由之路(一)]]></title>
    <url>%2F2017%2F08%2F29%2F%E9%80%9A%E5%BE%80%E8%B4%A2%E5%AF%8C%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[注意力 三个大坑1.莫名其妙的凑热闹路边围观,网上围观 即传说中的吃瓜群众！ 2.心急火燎的随大流~~~~跟随趋势！ 一旦什么东西火了就心急火燎的去随大流！ —— 趋势不属于心急火燎的人 机会是属于有准备的人 ——&gt; 做好自己的积累 3.操碎了别人的心别人的事 成功与否与我何干！！！ 结论注意力在一天内其实很少！ 注意力是你最宝贵的财富！！！ 把注意力放在自己的成长上！ 生活/创业 都是成长 每天一点点的的成长就是最好的财富 付费 凡是能用钱买的就是便宜的~~~！！！ 注意力 &gt; 时间 &gt; 金钱 时间 vs 金钱比如说外卖~ 在撸代码的时候 花几块钱让别人送个外卖过来 在同等时间内我敲代码产生的效益比这个更有价值 特别是起身去买外卖的时候会打扰目前撸代码的时的注意力 注意力 vs 时间注意力能创建价值 而时间并不一定 特别是有些时候我们还想要去杀死时间！ 撸游戏、看热闹！~~ 安全感]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[https配置]]></title>
    <url>%2F2017%2F07%2F31%2Fhttps%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[https配置1234567891011121314151617181920212223server &#123; listen 80; server_name hr.dduke.me; rewrite ^(.*) https://$host$1 permanent;&#125;server &#123; listen 443; server_name hr.dduke.me; #rewrite ^(.*) https://$host$1 permanent; ssl on; ssl_certificate 1_hr.dduke.me_bundle.crt; ssl_certificate_key 2_hr.dduke.me.key; ssl_session_timeout 5m; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置 ssl_prefer_server_ciphers on; location / &#123; proxy_pass http://127.0.0.1:8082; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125;]]></content>
      <categories>
        <category>全栈</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mongoose Date小坑]]></title>
    <url>%2F2017%2F07%2F18%2FMongoose%20Date%E5%B0%8F%E5%9D%91%2F</url>
    <content type="text"><![CDATA[Mongoose Date小坑今天在用nodejs做后端 mongo做数据库的一个应用时发的一个坑。 12345678910111213// 假设有这样一个状态let where = &#123; create_date: &#123; $gte: "2017-07-10T16:00:00.000Z", $lt: "2017-07-17T16:00:00.000Z" &#125;&#125;mongoDB.find(where).exec().then(result =&gt; &#123; console.log(result) // 该处能正常查询获取到数据&#125;)mongoDB.aggregate().match(where).exec().then(result =&gt; &#123; console.log(result) // 该处不能正常查询获取到数据&#125;) find时 Date类型的数据可以直接用字符串 match时不行! 思考解决若将其转化为 Date类型是否可行 ？ 故做了以下测试 123456789101112let where = &#123; create_date: &#123; $gte: new Date("2017-07-10T16:00:00.000Z"), $lt: new Date("2017-07-17T16:00:00.000Z") &#125;&#125;mongoDB.find(where).exec().then(result =&gt; &#123; console.log(result) // 该处能正常查询获取到数据&#125;)mongoDB.aggregate().match(where).exec().then(result =&gt; &#123; console.log(result) // 该处能正常查询获取到数据&#125;) OK fixed! ps.这个算 mongoose的bug吗？ 哈哈😄]]></content>
      <categories>
        <category>踩坑</category>
      </categories>
      <tags>
        <tag>Mongoose</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个服务器多端口多域名]]></title>
    <url>%2F2017%2F07%2F04%2F%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%9A%E7%AB%AF%E5%8F%A3%E5%A4%9A%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[前言本人比较穷,就只买了一台服务器玩玩。域名的话可以有很多(子域名基本上可以无限建)，为了给每个项目都分配一个域名，并且都能通过80端口访问到。(ps.域名后面再加一个端口 看起来有点蛋疼) 正题使用的是nginx做端口转发，实现起来也比较简单。修改nginx的配置(本文系统是基于Centos 7),若使用yum install的话 nginx的配置文件路径为 /etc/nginx/nginx.conf, 具体代码参考如下: 1234567891011121314151617181920server &#123; listen 80; server_name chat.dduke.me; location / &#123; proxy_pass http://127.0.0.1:8080; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125;server &#123; listen 80; server_name topasm.dduke.me; location / &#123; proxy_pass http://127.0.0.1:8081; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; ps.配置完后 不要忘记重新加载nginx配置1nginx -s reload]]></content>
      <categories>
        <category>全栈</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>域名绑定</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法 for javascript]]></title>
    <url>%2F2017%2F06%2F26%2F%E7%AE%97%E6%B3%95%20for%20javascript%2F</url>
    <content type="text"><![CDATA[为什么要学习算法(for javascript)学java出身,对算法这个东西有个一定的了解，然而对应带javascript上来，其实是一脸懵逼的。对目前从事前端的本人来说，把这个搞定，自认是至关重要的。之前写的博客，数据被黑，里面的数据全被清空了 ，这个新的博客算一个新的开始吧。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>算法</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F04%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[这是一个测试Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Hello world</tag>
      </tags>
  </entry>
</search>
